{"ast":null,"code":"var _regeneratorRuntime = require(\"/project/remora/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/project/remora/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _objectSpread = require(\"/project/remora/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/project/remora/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/project/remora/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/project/remora/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/project/remora/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar ow = require('ow').default;\nvar ResourceClient = require('../base/resource_client');\nvar _require = require('../utils'),\n  pluckData = _require.pluckData,\n  parseDateFields = _require.parseDateFields;\n\n/**\n * @hideconstructor\n */\nvar BuildClient = /*#__PURE__*/function (_ResourceClient) {\n  \"use strict\";\n\n  _inherits(BuildClient, _ResourceClient);\n  var _super = _createSuper(BuildClient);\n  /**\n   * @param {ApiClientOptions} options\n   */\n  function BuildClient(options) {\n    _classCallCheck(this, BuildClient);\n    return _super.call(this, _objectSpread({\n      resourcePath: 'actor-builds'\n    }, options));\n  }\n\n  /**\n   * https://docs.apify.com/api/v2#/reference/actor-builds/build-object/get-build\n   * @param {object} [options]\n   * @param {number} [options.waitForFinish]\n   * @return {Promise<Build>}\n   */\n  _createClass(BuildClient, [{\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var options,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n              ow(options, ow.object.exactShape({\n                waitForFinish: ow.optional.number\n              }));\n              return _context.abrupt(\"return\", this._get(options));\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function get() {\n        return _get.apply(this, arguments);\n      }\n      return get;\n    }()\n    /**\n     * https://docs.apify.com/api/v2#/reference/actor-builds/abort-build/abort-build\n     * @return {Promise<Build>}\n     */\n  }, {\n    key: \"abort\",\n    value: function () {\n      var _abort = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.httpClient.call({\n                url: this._url('abort'),\n                method: 'POST',\n                params: this._params()\n              });\n            case 2:\n              response = _context2.sent;\n              return _context2.abrupt(\"return\", parseDateFields(pluckData(response.data)));\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function abort() {\n        return _abort.apply(this, arguments);\n      }\n      return abort;\n    }()\n    /**\n     * Returns a promise that resolves with the finished Build object when the provided actor build finishes\n     * or with the unfinished Build object when the `waitSecs` timeout lapses. The promise is NOT rejected\n     * based on run status. You can inspect the `status` property of the Build object to find out its status.\n     *\n     * The difference between this function and the `waitForFinish` parameter of the `get` method\n     * is the fact that this function can wait indefinitely. Its use is preferable to the\n     * `waitForFinish` parameter alone, which it uses internally.\n     *\n     * This is useful when you need to immediately start a run after a build finishes.\n     *\n     * @param {object} [options]\n     * @param {number} [options.waitSecs]\n     *  Maximum time to wait for the build to finish, in seconds.\n     *  If the limit is reached, the returned promise is resolved to a build object that will have\n     *  status `READY` or `RUNNING`. If `waitSecs` omitted, the function waits indefinitely.\n     * @returns {Promise<Build>}\n     */\n  }, {\n    key: \"waitForFinish\",\n    value: function () {\n      var _waitForFinish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var options,\n          _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n              ow(options, ow.object.exactShape({\n                waitSecs: ow.optional.number\n              }));\n              return _context3.abrupt(\"return\", this._waitForFinish(options));\n            case 3:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function waitForFinish() {\n        return _waitForFinish.apply(this, arguments);\n      }\n      return waitForFinish;\n    }()\n  }]);\n  return BuildClient;\n}(ResourceClient);\nmodule.exports = BuildClient;","map":{"version":3,"names":["ow","require","default","ResourceClient","_require","pluckData","parseDateFields","BuildClient","_ResourceClient","_inherits","_super","_createSuper","options","_classCallCheck","call","_objectSpread","resourcePath","_createClass","key","value","_get","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_args","arguments","wrap","_callee$","_context","prev","next","length","undefined","object","exactShape","waitForFinish","optional","number","abrupt","stop","get","apply","_abort","_callee2","response","_callee2$","_context2","httpClient","url","_url","method","params","_params","sent","data","abort","_waitForFinish","_callee3","_args3","_callee3$","_context3","waitSecs","module","exports"],"sources":["/project/remora/node_modules/apify-client/src/resource_clients/build.js"],"sourcesContent":["const ow = require('ow').default;\nconst ResourceClient = require('../base/resource_client');\nconst {\n    pluckData,\n    parseDateFields,\n} = require('../utils');\n\n/**\n * @hideconstructor\n */\nclass BuildClient extends ResourceClient {\n    /**\n     * @param {ApiClientOptions} options\n     */\n    constructor(options) {\n        super({\n            resourcePath: 'actor-builds',\n            ...options,\n        });\n    }\n\n    /**\n     * https://docs.apify.com/api/v2#/reference/actor-builds/build-object/get-build\n     * @param {object} [options]\n     * @param {number} [options.waitForFinish]\n     * @return {Promise<Build>}\n     */\n    async get(options = {}) {\n        ow(options, ow.object.exactShape({\n            waitForFinish: ow.optional.number,\n        }));\n        return this._get(options);\n    }\n\n    /**\n     * https://docs.apify.com/api/v2#/reference/actor-builds/abort-build/abort-build\n     * @return {Promise<Build>}\n     */\n    async abort() {\n        const response = await this.httpClient.call({\n            url: this._url('abort'),\n            method: 'POST',\n            params: this._params(),\n        });\n\n        return parseDateFields(pluckData(response.data));\n    }\n\n    /**\n     * Returns a promise that resolves with the finished Build object when the provided actor build finishes\n     * or with the unfinished Build object when the `waitSecs` timeout lapses. The promise is NOT rejected\n     * based on run status. You can inspect the `status` property of the Build object to find out its status.\n     *\n     * The difference between this function and the `waitForFinish` parameter of the `get` method\n     * is the fact that this function can wait indefinitely. Its use is preferable to the\n     * `waitForFinish` parameter alone, which it uses internally.\n     *\n     * This is useful when you need to immediately start a run after a build finishes.\n     *\n     * @param {object} [options]\n     * @param {number} [options.waitSecs]\n     *  Maximum time to wait for the build to finish, in seconds.\n     *  If the limit is reached, the returned promise is resolved to a build object that will have\n     *  status `READY` or `RUNNING`. If `waitSecs` omitted, the function waits indefinitely.\n     * @returns {Promise<Build>}\n     */\n    async waitForFinish(options = {}) {\n        ow(options, ow.object.exactShape({\n            waitSecs: ow.optional.number,\n        }));\n        return this._waitForFinish(options);\n    }\n}\n\nmodule.exports = BuildClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}