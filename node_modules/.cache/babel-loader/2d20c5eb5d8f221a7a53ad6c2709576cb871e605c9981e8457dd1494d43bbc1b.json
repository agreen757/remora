{"ast":null,"code":"var _regeneratorRuntime = require(\"/project/remora/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/project/remora/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _slicedToArray = require(\"/project/remora/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/project/remora/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/project/remora/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar retry = require('async-retry');\nvar axios = require('axios').default;\nvar KeepAliveAgent = require('agentkeepalive');\nvar os = require('os');\nvar ApifyApiError = require('./apify_api_error');\nvar _require = require('./interceptors'),\n  InvalidResponseBodyError = _require.InvalidResponseBodyError,\n  requestInterceptors = _require.requestInterceptors,\n  responseInterceptors = _require.responseInterceptors;\nvar _require2 = require('./utils'),\n  isNode = _require2.isNode;\nvar _require3 = require('../package.json'),\n  version = _require3.version;\nvar RATE_LIMIT_EXCEEDED_STATUS_CODE = 429;\nvar HttpClient = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * @param {object} options\n   * @param {object} options.apifyClientStats\n   * @param {number} options.maxRetries\n   * @param {number} options.minDelayBetweenRetriesMillis\n   * @param {function[]} options.requestInterceptors\n   * @param {number} options.timeoutSecs\n   * @param {object} options.logger\n   */\n  function HttpClient(options) {\n    var _this = this;\n    _classCallCheck(this, HttpClient);\n    this.stats = options.apifyClientStats;\n    this.maxRetries = options.maxRetries;\n    this.minDelayBetwenRetriesMillis = options.minDelayBetweenRetriesMillis;\n    this.userProvidedRequestInterceptors = options.requestInterceptors;\n    this.logger = options.logger;\n    this._onRequestRetry = this._onRequestRetry.bind(this);\n    if (isNode()) {\n      // Add keep-alive agents that are preset with reasonable defaults.\n      // Axios will only use those in Node.js.\n      this.httpAgent = new KeepAliveAgent();\n      this.httpsAgent = new KeepAliveAgent.HttpsAgent();\n    }\n    this.axios = axios.create({\n      headers: {\n        Accept: 'application/json, */*'\n      },\n      httpAgent: this.httpAgent,\n      httpsAgent: this.httpsAgent,\n      paramsSerializer: function paramsSerializer(params) {\n        var formattedParams = Object.entries(params).filter(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            value = _ref2[1];\n          return value !== undefined;\n        }).map(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n            key = _ref4[0],\n            value = _ref4[1];\n          var updatedValue = typeof value === 'boolean' ? Number(value) : value;\n          return [key, updatedValue];\n        });\n        return new URLSearchParams(formattedParams);\n      },\n      validateStatus: null,\n      // Using interceptors for this functionality.\n      transformRequest: null,\n      transformResponse: null,\n      responseType: 'arraybuffer',\n      timeout: options.timeoutSecs * 1000,\n      maxContentLength: Infinity,\n      maxBodyLength: Infinity\n    });\n\n    // Clean all default headers because they only make a mess\n    // and their merging is difficult to understand and buggy.\n    this.axios.defaults.headers = {};\n    if (isNode()) {\n      // Works only in Node. Cannot be set in browser\n      var userAgent = \"ApifyClient/\".concat(version, \" (\").concat(os.type(), \"; Node/\").concat(process.version, \"); isAtHome/\").concat(!!process.env.IS_AT_HOME);\n      this.axios.defaults.headers['User-Agent'] = userAgent;\n    }\n    requestInterceptors.forEach(function (i) {\n      return _this.axios.interceptors.request.use(i);\n    });\n    this.userProvidedRequestInterceptors.forEach(function (i) {\n      return _this.axios.interceptors.request.use(i);\n    });\n    responseInterceptors.forEach(function (i) {\n      return _this.axios.interceptors.response.use(i);\n    });\n  }\n\n  /**\n   * @param {object} config\n   * @return {Promise<*>}\n   */\n  _createClass(HttpClient, [{\n    key: \"call\",\n    value: function () {\n      var _call = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(config) {\n        var makeRequest;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              this.stats.calls++;\n              makeRequest = this._createRequestHandler(config);\n              return _context.abrupt(\"return\", retry(makeRequest, {\n                retries: this.maxRetries,\n                minTimeout: this.minDelayBetwenRetriesMillis,\n                onRetry: this._onRequestRetry\n              }));\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function call(_x) {\n        return _call.apply(this, arguments);\n      }\n      return call;\n    }()\n    /**\n     * Successful responses are returned, errors and unsuccessful\n     * status codes are retried. See the following functions for the\n     * retrying logic.\n     * @param config\n     * @return {function}\n     * @private\n     */\n  }, {\n    key: \"_createRequestHandler\",\n    value: function _createRequestHandler(config) {\n      var _this2 = this;\n      /**\n       * @param {function} stopTrying\n       * @param {number} attempt\n       * @return {?Promise<AxiosResponse<any>>}\n       * @private\n       */\n      var makeRequest = /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(stopTrying, attempt) {\n          var response, apiError;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                _this2.stats.requests++;\n                _context2.prev = 1;\n                _context2.next = 4;\n                return _this2.axios.request(config);\n              case 4:\n                response = _context2.sent;\n                if (!_this2._isStatusOk(response.status)) {\n                  _context2.next = 7;\n                  break;\n                }\n                return _context2.abrupt(\"return\", response);\n              case 7:\n                _context2.next = 16;\n                break;\n              case 9:\n                _context2.prev = 9;\n                _context2.t0 = _context2[\"catch\"](1);\n                if (!_this2._isRetryableError(_context2.t0)) {\n                  _context2.next = 15;\n                  break;\n                }\n                throw _context2.t0;\n              case 15:\n                return _context2.abrupt(\"return\", stopTrying(_context2.t0));\n              case 16:\n                if (response.status === RATE_LIMIT_EXCEEDED_STATUS_CODE) {\n                  _this2.stats.addRateLimitError(attempt);\n                }\n                apiError = new ApifyApiError(response, attempt);\n                if (!_this2._isStatusCodeRetryable(response.status)) {\n                  _context2.next = 22;\n                  break;\n                }\n                throw apiError;\n              case 22:\n                return _context2.abrupt(\"return\", stopTrying(apiError));\n              case 23:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2, null, [[1, 9]]);\n        }));\n        return function makeRequest(_x2, _x3) {\n          return _ref5.apply(this, arguments);\n        };\n      }();\n      return makeRequest;\n    }\n\n    /**\n     * @param {number} statusCode\n     * @return {boolean}\n     * @private\n     */\n  }, {\n    key: \"_isStatusOk\",\n    value: function _isStatusOk(statusCode) {\n      return statusCode < 300;\n    }\n\n    /**\n     * We don't want to retry every exception thrown from Axios.\n     * The common denominator for retryable errors are network issues.\n     * @param {Error} err\n     * @private\n     */\n  }, {\n    key: \"_isRetryableError\",\n    value: function _isRetryableError(err) {\n      return this._isNetworkError(err) || this._isResponseBodyInvalid(err);\n    }\n\n    /**\n     * When a network connection to our API is interrupted in the middle of streaming\n     * a response, the request often does not fail, but simply contains\n     * an incomplete response. This can often be fixed by retrying.\n     * @param {Error} err\n     * @return {boolean}\n     * @private\n     */\n  }, {\n    key: \"_isResponseBodyInvalid\",\n    value: function _isResponseBodyInvalid(err) {\n      return err instanceof InvalidResponseBodyError;\n    }\n\n    /**\n     * When a network request is attempted by axios and fails,\n     * it throws an AxiosError, which will have the request\n     * and config (and other) properties.\n     * @param {Error} err\n     * @return {boolean}\n     * @private\n     */\n  }, {\n    key: \"_isNetworkError\",\n    value: function _isNetworkError(err) {\n      var hasRequest = err.request && typeof err.request === 'object';\n      var hasConfig = err.config && typeof err.config === 'object';\n      return hasRequest && hasConfig;\n    }\n\n    /**\n     * We retry 429 (rate limit) and 500+.\n     * For status codes 300-499 (except 429) we do not retry the request,\n     * because it's probably caused by invalid url (redirect 3xx) or invalid user input (4xx).\n     * @param {number} statusCode\n     * @return {boolean}\n     * @private\n     */\n  }, {\n    key: \"_isStatusCodeRetryable\",\n    value: function _isStatusCodeRetryable(statusCode) {\n      var isRateLimitError = statusCode === RATE_LIMIT_EXCEEDED_STATUS_CODE;\n      var isInternalError = statusCode >= 500;\n      return isRateLimitError || isInternalError;\n    }\n\n    /**\n     * @param {ApifyApiError} error\n     * @param {number} attempt\n     * @private\n     */\n  }, {\n    key: \"_onRequestRetry\",\n    value: function _onRequestRetry(error, attempt) {\n      if (attempt === Math.round(this.maxRetries / 2)) {\n        this.logger.warning(\"API request failed \".concat(attempt, \" times. Max attempts: \").concat(this.maxRetries + 1, \".\\nCause:\").concat(error.stack));\n      }\n    }\n  }]);\n  return HttpClient;\n}();\nmodule.exports = HttpClient;","map":{"version":3,"names":["retry","require","axios","default","KeepAliveAgent","os","ApifyApiError","_require","InvalidResponseBodyError","requestInterceptors","responseInterceptors","_require2","isNode","_require3","version","RATE_LIMIT_EXCEEDED_STATUS_CODE","HttpClient","options","_this","_classCallCheck","stats","apifyClientStats","maxRetries","minDelayBetwenRetriesMillis","minDelayBetweenRetriesMillis","userProvidedRequestInterceptors","logger","_onRequestRetry","bind","httpAgent","httpsAgent","HttpsAgent","create","headers","Accept","paramsSerializer","params","formattedParams","Object","entries","filter","_ref","_ref2","_slicedToArray","value","undefined","map","_ref3","_ref4","key","updatedValue","Number","URLSearchParams","validateStatus","transformRequest","transformResponse","responseType","timeout","timeoutSecs","maxContentLength","Infinity","maxBodyLength","defaults","userAgent","concat","type","process","env","IS_AT_HOME","forEach","i","interceptors","request","use","response","_createClass","_call","_asyncToGenerator","_regeneratorRuntime","mark","_callee","config","makeRequest","wrap","_callee$","_context","prev","next","calls","_createRequestHandler","abrupt","retries","minTimeout","onRetry","stop","call","_x","apply","arguments","_this2","_ref5","_callee2","stopTrying","attempt","apiError","_callee2$","_context2","requests","sent","_isStatusOk","status","t0","_isRetryableError","addRateLimitError","_isStatusCodeRetryable","_x2","_x3","statusCode","err","_isNetworkError","_isResponseBodyInvalid","hasRequest","hasConfig","isRateLimitError","isInternalError","error","Math","round","warning","stack","module","exports"],"sources":["/project/remora/node_modules/apify-client/src/http_client.js"],"sourcesContent":["const retry = require('async-retry');\nconst axios = require('axios').default;\nconst KeepAliveAgent = require('agentkeepalive');\nconst os = require('os');\nconst ApifyApiError = require('./apify_api_error');\nconst {\n    InvalidResponseBodyError,\n    requestInterceptors,\n    responseInterceptors,\n} = require('./interceptors');\nconst {\n    isNode,\n} = require('./utils');\nconst { version } = require('../package.json');\n\nconst RATE_LIMIT_EXCEEDED_STATUS_CODE = 429;\n\nclass HttpClient {\n    /**\n     * @param {object} options\n     * @param {object} options.apifyClientStats\n     * @param {number} options.maxRetries\n     * @param {number} options.minDelayBetweenRetriesMillis\n     * @param {function[]} options.requestInterceptors\n     * @param {number} options.timeoutSecs\n     * @param {object} options.logger\n     */\n    constructor(options) {\n        this.stats = options.apifyClientStats;\n        this.maxRetries = options.maxRetries;\n        this.minDelayBetwenRetriesMillis = options.minDelayBetweenRetriesMillis;\n        this.userProvidedRequestInterceptors = options.requestInterceptors;\n        this.logger = options.logger;\n        this._onRequestRetry = this._onRequestRetry.bind(this);\n\n        if (isNode()) {\n            // Add keep-alive agents that are preset with reasonable defaults.\n            // Axios will only use those in Node.js.\n            this.httpAgent = new KeepAliveAgent();\n            this.httpsAgent = new KeepAliveAgent.HttpsAgent();\n        }\n\n        this.axios = axios.create({\n            headers: {\n                Accept: 'application/json, */*',\n            },\n            httpAgent: this.httpAgent,\n            httpsAgent: this.httpsAgent,\n            paramsSerializer: (params) => {\n                const formattedParams = Object.entries(params)\n                    .filter(([, value]) => value !== undefined)\n                    .map(([key, value]) => {\n                        const updatedValue = typeof value === 'boolean' ? Number(value) : value;\n                        return [key, updatedValue];\n                    });\n\n                return new URLSearchParams(formattedParams);\n            },\n            validateStatus: null,\n            // Using interceptors for this functionality.\n            transformRequest: null,\n            transformResponse: null,\n            responseType: 'arraybuffer',\n            timeout: options.timeoutSecs * 1000,\n            maxContentLength: Infinity,\n            maxBodyLength: Infinity,\n        });\n\n        // Clean all default headers because they only make a mess\n        // and their merging is difficult to understand and buggy.\n        this.axios.defaults.headers = {};\n\n        if (isNode()) {\n            // Works only in Node. Cannot be set in browser\n            const userAgent = `ApifyClient/${version} (${os.type()}; Node/${process.version}); isAtHome/${!!process.env.IS_AT_HOME}`;\n            this.axios.defaults.headers['User-Agent'] = userAgent;\n        }\n\n        requestInterceptors.forEach((i) => this.axios.interceptors.request.use(i));\n        this.userProvidedRequestInterceptors.forEach((i) => this.axios.interceptors.request.use(i));\n        responseInterceptors.forEach((i) => this.axios.interceptors.response.use(i));\n    }\n\n    /**\n     * @param {object} config\n     * @return {Promise<*>}\n     */\n    async call(config) {\n        this.stats.calls++;\n        const makeRequest = this._createRequestHandler(config);\n\n        return retry(makeRequest, {\n            retries: this.maxRetries,\n            minTimeout: this.minDelayBetwenRetriesMillis,\n            onRetry: this._onRequestRetry,\n        });\n    }\n\n    /**\n     * Successful responses are returned, errors and unsuccessful\n     * status codes are retried. See the following functions for the\n     * retrying logic.\n     * @param config\n     * @return {function}\n     * @private\n     */\n    _createRequestHandler(config) {\n        /**\n         * @param {function} stopTrying\n         * @param {number} attempt\n         * @return {?Promise<AxiosResponse<any>>}\n         * @private\n         */\n        const makeRequest = async (stopTrying, attempt) => {\n            this.stats.requests++;\n            let response;\n            try {\n                response = await this.axios.request(config);\n                if (this._isStatusOk(response.status)) return response;\n            } catch (err) {\n                if (this._isRetryableError(err)) {\n                    throw err;\n                } else {\n                    return stopTrying(err);\n                }\n            }\n\n            if (response.status === RATE_LIMIT_EXCEEDED_STATUS_CODE) {\n                this.stats.addRateLimitError(attempt);\n            }\n\n            const apiError = new ApifyApiError(response, attempt);\n            if (this._isStatusCodeRetryable(response.status)) {\n                throw apiError;\n            } else {\n                return stopTrying(apiError);\n            }\n        };\n        return makeRequest;\n    }\n\n    /**\n     * @param {number} statusCode\n     * @return {boolean}\n     * @private\n     */\n    _isStatusOk(statusCode) {\n        return statusCode < 300;\n    }\n\n    /**\n     * We don't want to retry every exception thrown from Axios.\n     * The common denominator for retryable errors are network issues.\n     * @param {Error} err\n     * @private\n     */\n    _isRetryableError(err) {\n        return this._isNetworkError(err) || this._isResponseBodyInvalid(err);\n    }\n\n    /**\n     * When a network connection to our API is interrupted in the middle of streaming\n     * a response, the request often does not fail, but simply contains\n     * an incomplete response. This can often be fixed by retrying.\n     * @param {Error} err\n     * @return {boolean}\n     * @private\n     */\n    _isResponseBodyInvalid(err) {\n        return err instanceof InvalidResponseBodyError;\n    }\n\n    /**\n     * When a network request is attempted by axios and fails,\n     * it throws an AxiosError, which will have the request\n     * and config (and other) properties.\n     * @param {Error} err\n     * @return {boolean}\n     * @private\n     */\n    _isNetworkError(err) {\n        const hasRequest = err.request && typeof err.request === 'object';\n        const hasConfig = err.config && typeof err.config === 'object';\n        return hasRequest && hasConfig;\n    }\n\n    /**\n     * We retry 429 (rate limit) and 500+.\n     * For status codes 300-499 (except 429) we do not retry the request,\n     * because it's probably caused by invalid url (redirect 3xx) or invalid user input (4xx).\n     * @param {number} statusCode\n     * @return {boolean}\n     * @private\n     */\n    _isStatusCodeRetryable(statusCode) {\n        const isRateLimitError = statusCode === RATE_LIMIT_EXCEEDED_STATUS_CODE;\n        const isInternalError = statusCode >= 500;\n        return isRateLimitError || isInternalError;\n    }\n\n    /**\n     * @param {ApifyApiError} error\n     * @param {number} attempt\n     * @private\n     */\n    _onRequestRetry(error, attempt) {\n        if (attempt === Math.round(this.maxRetries / 2)) {\n            this.logger.warning(`API request failed ${attempt} times. Max attempts: ${this.maxRetries + 1}.\\nCause:${error.stack}`);\n        }\n    }\n}\n\nmodule.exports = HttpClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}