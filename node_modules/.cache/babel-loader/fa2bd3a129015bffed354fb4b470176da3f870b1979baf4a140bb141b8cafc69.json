{"ast":null,"code":"var _regeneratorRuntime = require(\"/project/remora/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/project/remora/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _slicedToArray = require(\"/project/remora/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createClass = require(\"/project/remora/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/project/remora/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _inherits = require(\"/project/remora/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/project/remora/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _wrapNativeSuper = require(\"/project/remora/node_modules/@babel/runtime/helpers/wrapNativeSuper.js\").default;\nvar axios = require('axios');\nvar _require = require('./body_parser'),\n  maybeParseBody = _require.maybeParseBody;\nvar _require2 = require('./utils'),\n  isNode = _require2.isNode,\n  maybeGzipValue = _require2.maybeGzipValue;\n\n/**\n * This error exists for the quite common situation, where only a partial JSON response is received and\n * an attempt to parse the JSON throws an error. In most cases this can be resolved by retrying the\n * request. We do that by identifying this error in HttpClient.\n *\n * The properties mimic AxiosError for easier integration in HttpClient error handling.\n */\nvar InvalidResponseBodyError = /*#__PURE__*/function (_Error) {\n  \"use strict\";\n\n  _inherits(InvalidResponseBodyError, _Error);\n  var _super = _createSuper(InvalidResponseBodyError);\n  function InvalidResponseBodyError(response, cause) {\n    var _this;\n    _classCallCheck(this, InvalidResponseBodyError);\n    _this = _super.call(this, \"Response body could not be parsed.\\nCause:\".concat(cause.message));\n    _this.name = _this.constructor.name;\n    _this.code = 'invalid-response-body';\n    _this.response = response;\n    _this.cause = cause;\n    return _this;\n  }\n  return _createClass(InvalidResponseBodyError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * @param {object} config\n * @return {object}\n */\nfunction serializeRequest(config) {\n  var _axios$defaults$trans = _slicedToArray(axios.defaults.transformRequest, 1),\n    defaultTransform = _axios$defaults$trans[0];\n  config.data = defaultTransform(config.data, config.headers);\n  return config;\n}\n\n/**\n * @param {object} config\n * @return {Promise<object>}\n */\nfunction maybeGzipRequest(_x) {\n  return _maybeGzipRequest.apply(this, arguments);\n}\n/**\n * @param {AxiosResponse} response\n * @return {AxiosResponse}\n */\nfunction _maybeGzipRequest() {\n  _maybeGzipRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(config) {\n    var maybeZippedData;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (!config.headers['content-encoding']) {\n            _context.next = 2;\n            break;\n          }\n          return _context.abrupt(\"return\", config);\n        case 2:\n          _context.next = 4;\n          return maybeGzipValue(config.data);\n        case 4:\n          maybeZippedData = _context.sent;\n          if (config.data !== maybeZippedData) {\n            config.headers['content-encoding'] = 'gzip';\n            config.data = maybeZippedData;\n          }\n          return _context.abrupt(\"return\", config);\n        case 7:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _maybeGzipRequest.apply(this, arguments);\n}\nfunction parseResponseData(response) {\n  if (!response.data // Nothing to do here.\n  || response.config.responseType !== 'arraybuffer' // We don't want to parse custom response types.\n  || response.config.forceBuffer // Apify custom property to prevent parsing of buffer.\n  ) {\n    return response;\n  }\n  var isBufferEmpty = isNode() ? !response.data.length : !response.data.byteLength;\n  if (isBufferEmpty) {\n    // undefined is better than an empty buffer\n    response.data = undefined;\n    return response;\n  }\n  var contentTypeHeader = response.headers['content-type'];\n  try {\n    response.data = maybeParseBody(response.data, contentTypeHeader);\n  } catch (err) {\n    throw new InvalidResponseBodyError(response, err);\n  }\n  return response;\n}\nvar requestInterceptors = [maybeGzipRequest, serializeRequest];\nvar responseInterceptors = [parseResponseData];\nmodule.exports = {\n  InvalidResponseBodyError: InvalidResponseBodyError,\n  requestInterceptors: requestInterceptors,\n  responseInterceptors: responseInterceptors\n};","map":{"version":3,"names":["axios","require","_require","maybeParseBody","_require2","isNode","maybeGzipValue","InvalidResponseBodyError","_Error","_inherits","_super","_createSuper","response","cause","_this","_classCallCheck","call","concat","message","name","constructor","code","_createClass","_wrapNativeSuper","Error","serializeRequest","config","_axios$defaults$trans","_slicedToArray","defaults","transformRequest","defaultTransform","data","headers","maybeGzipRequest","_x","_maybeGzipRequest","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","maybeZippedData","wrap","_callee$","_context","prev","next","abrupt","sent","stop","parseResponseData","responseType","forceBuffer","isBufferEmpty","length","byteLength","undefined","contentTypeHeader","err","requestInterceptors","responseInterceptors","module","exports"],"sources":["/project/remora/node_modules/apify-client/src/interceptors.js"],"sourcesContent":["const axios = require('axios');\nconst { maybeParseBody } = require('./body_parser');\nconst {\n    isNode,\n    maybeGzipValue,\n} = require('./utils');\n\n/**\n * This error exists for the quite common situation, where only a partial JSON response is received and\n * an attempt to parse the JSON throws an error. In most cases this can be resolved by retrying the\n * request. We do that by identifying this error in HttpClient.\n *\n * The properties mimic AxiosError for easier integration in HttpClient error handling.\n */\nclass InvalidResponseBodyError extends Error {\n    constructor(response, cause) {\n        super(`Response body could not be parsed.\\nCause:${cause.message}`);\n        this.name = this.constructor.name;\n        this.code = 'invalid-response-body';\n        this.response = response;\n        this.cause = cause;\n    }\n}\n\n/**\n * @param {object} config\n * @return {object}\n */\nfunction serializeRequest(config) {\n    const [defaultTransform] = axios.defaults.transformRequest;\n    config.data = defaultTransform(config.data, config.headers);\n    return config;\n}\n\n/**\n * @param {object} config\n * @return {Promise<object>}\n */\nasync function maybeGzipRequest(config) {\n    if (config.headers['content-encoding']) return config;\n    const maybeZippedData = await maybeGzipValue(config.data);\n    if (config.data !== maybeZippedData) {\n        config.headers['content-encoding'] = 'gzip';\n        config.data = maybeZippedData;\n    }\n    return config;\n}\n\n/**\n * @param {AxiosResponse} response\n * @return {AxiosResponse}\n */\nfunction parseResponseData(response) {\n    if (\n        !response.data // Nothing to do here.\n        || response.config.responseType !== 'arraybuffer' // We don't want to parse custom response types.\n        || response.config.forceBuffer // Apify custom property to prevent parsing of buffer.\n    ) {\n        return response;\n    }\n\n    const isBufferEmpty = isNode() ? !response.data.length : !response.data.byteLength;\n    if (isBufferEmpty) {\n        // undefined is better than an empty buffer\n        response.data = undefined;\n        return response;\n    }\n\n    const contentTypeHeader = response.headers['content-type'];\n    try {\n        response.data = maybeParseBody(response.data, contentTypeHeader);\n    } catch (err) {\n        throw new InvalidResponseBodyError(response, err);\n    }\n\n    return response;\n}\n\nconst requestInterceptors = [maybeGzipRequest, serializeRequest];\nconst responseInterceptors = [parseResponseData];\n\nmodule.exports = {\n    InvalidResponseBodyError,\n    requestInterceptors,\n    responseInterceptors,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}