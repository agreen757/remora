{"ast":null,"code":"var _slicedToArray = require(\"/project/remora/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _objectWithoutProperties = require(\"/project/remora/node_modules/@babel/runtime/helpers/objectWithoutProperties.js\").default;\nvar _classCallCheck = require(\"/project/remora/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/project/remora/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/project/remora/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/project/remora/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _wrapNativeSuper = require(\"/project/remora/node_modules/@babel/runtime/helpers/wrapNativeSuper.js\").default;\nvar _excluded = [\"name\"];\n/**\n * Examples of capturing groups for \"...at ActorCollectionClient._list (/Users/...\"\n * 0: \"at ActorCollectionClient._list (\"\n * 1: undefined\n * 2: \"ActorCollectionClient\"\n * 3: undefined\n * 4: \"list\"\n * @type {RegExp}\n * @private\n */\nvar CLIENT_METHOD_REGEX = /at( async)? ([A-Za-z]+(Collection)?Client)\\._?([A-Za-z]+) \\(/;\n\n/**\n * An `ApifyApiError` is thrown for successful HTTP requests that reach the API,\n * but the API responds with an error response. Typically, those are rate limit\n * errors and internal errors, which are automatically retried, or validation\n * errors, which are thrown immediately, because a correction by the user is\n * needed.\n *\n * @property {string} message\n *  Error message returned by the API.\n * @property {string} clientMethod\n *  The invoked resource client and the method. Known issue: Sometimes it displays\n *  as undefined because it can't be parsed from a stack trace.\n * @property {number} statusCode\n *  HTTP status code of the error.\n * @property {string} type\n *  The type of the error, as returned by the API.\n * @property {number} attempt\n *  Number of the API call attempt.\n * @property {string} httpMethod\n *  HTTP method of the API call.\n * @property {string} path\n *  Full path of the API endpoint (URL excluding origin).\n * @property {string} originalStack\n *  Original stack trace of the exception. It is replaced\n *  by a more informative stack with API call information.\n * @hideconstructor\n */\nvar ApifyApiError = /*#__PURE__*/function (_Error) {\n  \"use strict\";\n\n  _inherits(ApifyApiError, _Error);\n  var _super = _createSuper(ApifyApiError);\n  /**\n   * @param {AxiosResponse} response\n   * @param {number} attempt\n   */\n  function ApifyApiError(response, attempt) {\n    var _this;\n    _classCallCheck(this, ApifyApiError);\n    var message;\n    var type;\n    if (response.data && response.data.error) {\n      var error = response.data.error;\n      message = error.message;\n      type = error.type;\n    } else if (response.data) {\n      var dataString;\n      try {\n        dataString = JSON.stringify(response.data, null, 2);\n      } catch (err) {\n        dataString = \"\".concat(response.data);\n      }\n      message = \"Unexpected error: \".concat(dataString);\n    }\n    _this = _super.call(this, message);\n    _this.name = _this.constructor.name;\n    _this.clientMethod = _this._extractClientAndMethodFromStack();\n    _this.statusCode = response.status;\n    _this.type = type;\n    _this.attempt = attempt;\n    _this.httpMethod = response.config && response.config.method;\n    _this.path = _this._safelyParsePathFromResponse(response);\n    _this.originalStack = _this.stack.slice(_this.stack.indexOf('\\n'));\n    _this.stack = _this._createApiStack();\n    return _this;\n  }\n\n  /**\n   * @param {AxiosResponse} response\n   * @return {string}\n   * @private\n   */\n  _createClass(ApifyApiError, [{\n    key: \"_safelyParsePathFromResponse\",\n    value: function _safelyParsePathFromResponse(response) {\n      var urlString = response.config && response.config.url;\n      var url;\n      try {\n        url = new URL(urlString);\n      } catch (err) {\n        return urlString;\n      }\n      return url.pathname + url.search;\n    }\n\n    /**\n     * @return {string}\n     * @private\n     */\n  }, {\n    key: \"_extractClientAndMethodFromStack\",\n    value: function _extractClientAndMethodFromStack() {\n      var match = this.stack.match(CLIENT_METHOD_REGEX);\n      if (match) return \"\".concat(match[2], \".\").concat(match[4]);\n    }\n\n    /**\n     * Creates a better looking and more informative stack that will be printed\n     * out when API errors are thrown.\n     *\n     * Example:\n     *\n     * ApifyApiError: Actor task was not found\n     *   clientMethod: TaskClient.start\n     *   statusCode: 404\n     *   type: record-not-found\n     *   attempt: 1\n     *   httpMethod: post\n     *   path: /v2/actor-tasks/user~my-task/runs\n     *\n     * @return {string}\n     * @private\n     */\n  }, {\n    key: \"_createApiStack\",\n    value: function _createApiStack() {\n      var name = this.name,\n        props = _objectWithoutProperties(this, _excluded);\n      var stack = Object.entries(props).map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          k = _ref2[0],\n          v = _ref2[1];\n        // Rename originalStack to stack in the stack itself.\n        // This is for better readability of errors in log.\n        if (k === 'originalStack') k = 'stack';\n        return \"  \".concat(k, \": \").concat(v);\n      }).join('\\n');\n      return \"\".concat(name, \": \").concat(this.message, \"\\n\").concat(stack);\n    }\n  }]);\n  return ApifyApiError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nmodule.exports = ApifyApiError;","map":{"version":3,"names":["CLIENT_METHOD_REGEX","ApifyApiError","_Error","_inherits","_super","_createSuper","response","attempt","_this","_classCallCheck","message","type","data","error","dataString","JSON","stringify","err","concat","call","name","constructor","clientMethod","_extractClientAndMethodFromStack","statusCode","status","httpMethod","config","method","path","_safelyParsePathFromResponse","originalStack","stack","slice","indexOf","_createApiStack","_createClass","key","value","urlString","url","URL","pathname","search","match","props","_objectWithoutProperties","_excluded","Object","entries","map","_ref","_ref2","_slicedToArray","k","v","join","_wrapNativeSuper","Error","module","exports"],"sources":["/project/remora/node_modules/apify-client/src/apify_api_error.js"],"sourcesContent":["/**\n * Examples of capturing groups for \"...at ActorCollectionClient._list (/Users/...\"\n * 0: \"at ActorCollectionClient._list (\"\n * 1: undefined\n * 2: \"ActorCollectionClient\"\n * 3: undefined\n * 4: \"list\"\n * @type {RegExp}\n * @private\n */\nconst CLIENT_METHOD_REGEX = /at( async)? ([A-Za-z]+(Collection)?Client)\\._?([A-Za-z]+) \\(/;\n\n/**\n * An `ApifyApiError` is thrown for successful HTTP requests that reach the API,\n * but the API responds with an error response. Typically, those are rate limit\n * errors and internal errors, which are automatically retried, or validation\n * errors, which are thrown immediately, because a correction by the user is\n * needed.\n *\n * @property {string} message\n *  Error message returned by the API.\n * @property {string} clientMethod\n *  The invoked resource client and the method. Known issue: Sometimes it displays\n *  as undefined because it can't be parsed from a stack trace.\n * @property {number} statusCode\n *  HTTP status code of the error.\n * @property {string} type\n *  The type of the error, as returned by the API.\n * @property {number} attempt\n *  Number of the API call attempt.\n * @property {string} httpMethod\n *  HTTP method of the API call.\n * @property {string} path\n *  Full path of the API endpoint (URL excluding origin).\n * @property {string} originalStack\n *  Original stack trace of the exception. It is replaced\n *  by a more informative stack with API call information.\n * @hideconstructor\n */\nclass ApifyApiError extends Error {\n    /**\n     * @param {AxiosResponse} response\n     * @param {number} attempt\n     */\n    constructor(response, attempt) {\n        let message;\n        let type;\n        if (response.data && response.data.error) {\n            const { error } = response.data;\n            message = error.message;\n            type = error.type;\n        } else if (response.data) {\n            let dataString;\n            try {\n                dataString = JSON.stringify(response.data, null, 2);\n            } catch (err) {\n                dataString = `${response.data}`;\n            }\n            message = `Unexpected error: ${dataString}`;\n        }\n        super(message);\n\n        this.name = this.constructor.name;\n        this.clientMethod = this._extractClientAndMethodFromStack();\n        this.statusCode = response.status;\n        this.type = type;\n        this.attempt = attempt;\n        this.httpMethod = response.config && response.config.method;\n        this.path = this._safelyParsePathFromResponse(response);\n\n        this.originalStack = this.stack.slice(this.stack.indexOf('\\n'));\n        this.stack = this._createApiStack();\n    }\n\n    /**\n     * @param {AxiosResponse} response\n     * @return {string}\n     * @private\n     */\n    _safelyParsePathFromResponse(response) {\n        const urlString = response.config && response.config.url;\n        let url;\n        try {\n            url = new URL(urlString);\n        } catch (err) {\n            return urlString;\n        }\n        return url.pathname + url.search;\n    }\n\n    /**\n     * @return {string}\n     * @private\n     */\n    _extractClientAndMethodFromStack() {\n        const match = this.stack.match(CLIENT_METHOD_REGEX);\n        if (match) return `${match[2]}.${match[4]}`;\n    }\n\n    /**\n     * Creates a better looking and more informative stack that will be printed\n     * out when API errors are thrown.\n     *\n     * Example:\n     *\n     * ApifyApiError: Actor task was not found\n     *   clientMethod: TaskClient.start\n     *   statusCode: 404\n     *   type: record-not-found\n     *   attempt: 1\n     *   httpMethod: post\n     *   path: /v2/actor-tasks/user~my-task/runs\n     *\n     * @return {string}\n     * @private\n     */\n    _createApiStack() {\n        const {\n            name,\n            ...props\n        } = this;\n        const stack = Object.entries(props)\n            .map(([k, v]) => {\n                // Rename originalStack to stack in the stack itself.\n                // This is for better readability of errors in log.\n                if (k === 'originalStack') k = 'stack';\n                return `  ${k}: ${v}`;\n            })\n            .join('\\n');\n\n        return `${name}: ${this.message}\\n${stack}`;\n    }\n}\n\nmodule.exports = ApifyApiError;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}