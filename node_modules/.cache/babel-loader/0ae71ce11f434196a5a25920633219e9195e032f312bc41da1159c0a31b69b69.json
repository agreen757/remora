{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/project/remora/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _objectSpread = require(\"/project/remora/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/project/remora/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/project/remora/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Predicate = exports.validatorSymbol = void 0;\nvar is_1 = require(\"@sindresorhus/is\");\nvar argument_error_1 = require(\"../argument-error\");\nvar not_1 = require(\"../operators/not\");\nvar base_predicate_1 = require(\"./base-predicate\");\nvar generate_argument_error_message_1 = require(\"../utils/generate-argument-error-message\");\n/**\n@hidden\n*/\nexports.validatorSymbol = Symbol('validators');\n/**\n@hidden\n*/\nvar Predicate = /*#__PURE__*/function (_base_predicate_1$tes, _exports$validatorSym) {\n  function Predicate(type) {\n    var _this = this;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Predicate);\n    Object.defineProperty(this, \"type\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: type\n    });\n    Object.defineProperty(this, \"options\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: options\n    });\n    Object.defineProperty(this, \"context\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        validators: []\n      }\n    });\n    this.context = _objectSpread(_objectSpread({}, this.context), this.options);\n    var typeString = this.type.charAt(0).toLowerCase() + this.type.slice(1);\n    this.addValidator({\n      message: function message(value, label) {\n        // We do not include type in this label as we do for other messages, because it would be redundant.\n        var label_ = label === null || label === void 0 ? void 0 : label.slice(_this.type.length + 1);\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        return \"Expected \".concat(label_ || 'argument', \" to be of type `\").concat(_this.type, \"` but received type `\").concat(is_1.default(value), \"`\");\n      },\n      validator: function validator(value) {\n        return is_1.default[typeString](value);\n      }\n    });\n  }\n  /**\n  @hidden\n  */\n  _createClass(Predicate, [{\n    key: _base_predicate_1$tes,\n    value: function value(_value, main, label) {\n      // Create a map of labels -> received errors.\n      var errors = new Map();\n      var _iterator = _createForOfIteratorHelper(this.context.validators),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _step.value,\n            validator = _step$value.validator,\n            _message = _step$value.message;\n          if (this.options.optional === true && _value === undefined) {\n            continue;\n          }\n          var result = void 0;\n          try {\n            result = validator(_value);\n          } catch (error) {\n            // Any errors caught means validators couldn't process the input.\n            result = error;\n          }\n          if (result === true) {\n            continue;\n          }\n          var label2 = is_1.default.function_(label) ? label() : label;\n          var label_ = label2 ? \"\".concat(this.type, \" `\").concat(label2, \"`\") : this.type;\n          var mapKey = label2 || this.type;\n          // Get the current errors encountered for this label.\n          var currentErrors = errors.get(mapKey);\n          // Pre-generate the error message that will be reported to the user.\n          var errorMessage = _message(_value, label_, result);\n          // If we already have any errors for this label.\n          if (currentErrors) {\n            // If we don't already have this error logged, add it.\n            currentErrors.add(errorMessage);\n          } else {\n            // Set this label and error in the full map.\n            errors.set(mapKey, new Set([errorMessage]));\n          }\n        }\n        // If we have any errors to report, throw.\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (errors.size > 0) {\n        // Generate the `error.message` property.\n        var message = generate_argument_error_message_1.generateArgumentErrorMessage(errors);\n        throw new argument_error_1.ArgumentError(message, main, errors);\n      }\n    }\n    /**\n    @hidden\n    */\n  }, {\n    key: _exports$validatorSym,\n    get: function get() {\n      return this.context.validators;\n    }\n    /**\n    Invert the following validators.\n    */\n  }, {\n    key: \"not\",\n    get: function get() {\n      return not_1.not(this);\n    }\n    /**\n    Test if the value matches a custom validation function. The validation function should return an object containing a `validator` and `message`. If the `validator` is `false`, the validation fails and the `message` will be used as error message. If the `message` is a function, the function is invoked with the `label` as argument to let you further customize the error message.\n     @param customValidator - Custom validation function.\n    */\n  }, {\n    key: \"validate\",\n    value: function validate(customValidator) {\n      return this.addValidator({\n        message: function message(_, label, error) {\n          return typeof error === 'string' ? \"(\".concat(label, \") \").concat(error) : error(label);\n        },\n        validator: function validator(value) {\n          var _customValidator = customValidator(value),\n            message = _customValidator.message,\n            validator = _customValidator.validator;\n          if (validator) {\n            return true;\n          }\n          return message;\n        }\n      });\n    }\n    /**\n    Test if the value matches a custom validation function. The validation function should return `true` if the value passes the function. If the function either returns `false` or a string, the function fails and the string will be used as error message.\n     @param validator - Validation function.\n    */\n  }, {\n    key: \"is\",\n    value: function is(validator) {\n      return this.addValidator({\n        message: function message(value, label, error) {\n          return error ? \"(\".concat(label, \") \").concat(error) : \"Expected \".concat(label, \" `\").concat(value, \"` to pass custom validation function\");\n        },\n        validator: validator\n      });\n    }\n    /**\n    Provide a new error message to be thrown when the validation fails.\n     @param newMessage - Either a string containing the new message or a function returning the new message.\n     @example\n    ```\n    ow('ðŸŒˆ', 'unicorn', ow.string.equals('ðŸ¦„').message('Expected unicorn, got rainbow'));\n    //=> ArgumentError: Expected unicorn, got rainbow\n    ```\n     @example\n    ```\n    ow('ðŸŒˆ', ow.string.minLength(5).message((value, label) => `Expected ${label}, to have a minimum length of 5, got \\`${value}\\``));\n    //=> ArgumentError: Expected string, to be have a minimum length of 5, got `ðŸŒˆ`\n    ```\n    */\n  }, {\n    key: \"message\",\n    value: function message(newMessage) {\n      var validators = this.context.validators;\n      validators[validators.length - 1].message = function (value, label) {\n        if (typeof newMessage === 'function') {\n          return newMessage(value, label);\n        }\n        return newMessage;\n      };\n      return this;\n    }\n    /**\n    Register a new validator.\n     @param validator - Validator to register.\n    */\n  }, {\n    key: \"addValidator\",\n    value: function addValidator(validator) {\n      this.context.validators.push(validator);\n      return this;\n    }\n  }]);\n  return Predicate;\n}(base_predicate_1.testSymbol, exports.validatorSymbol);\nexports.Predicate = Predicate;","map":{"version":3,"names":["_createForOfIteratorHelper","require","default","_objectSpread","_classCallCheck","_createClass","Object","defineProperty","exports","value","Predicate","validatorSymbol","is_1","argument_error_1","not_1","base_predicate_1","generate_argument_error_message_1","Symbol","_base_predicate_1$tes","_exports$validatorSym","type","_this","options","arguments","length","undefined","enumerable","configurable","writable","validators","context","typeString","charAt","toLowerCase","slice","addValidator","message","label","label_","concat","validator","key","main","errors","Map","_iterator","_step","s","n","done","_step$value","optional","result","error","label2","function_","mapKey","currentErrors","get","errorMessage","add","set","Set","err","e","f","size","generateArgumentErrorMessage","ArgumentError","not","validate","customValidator","_","_customValidator","is","newMessage","push","testSymbol"],"sources":["/project/remora/node_modules/ow/dist/predicates/predicate.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Predicate = exports.validatorSymbol = void 0;\nconst is_1 = require(\"@sindresorhus/is\");\nconst argument_error_1 = require(\"../argument-error\");\nconst not_1 = require(\"../operators/not\");\nconst base_predicate_1 = require(\"./base-predicate\");\nconst generate_argument_error_message_1 = require(\"../utils/generate-argument-error-message\");\n/**\n@hidden\n*/\nexports.validatorSymbol = Symbol('validators');\n/**\n@hidden\n*/\nclass Predicate {\n    constructor(type, options = {}) {\n        Object.defineProperty(this, \"type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: type\n        });\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: options\n        });\n        Object.defineProperty(this, \"context\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                validators: []\n            }\n        });\n        this.context = {\n            ...this.context,\n            ...this.options\n        };\n        const typeString = this.type.charAt(0).toLowerCase() + this.type.slice(1);\n        this.addValidator({\n            message: (value, label) => {\n                // We do not include type in this label as we do for other messages, because it would be redundant.\n                const label_ = label === null || label === void 0 ? void 0 : label.slice(this.type.length + 1);\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n                return `Expected ${label_ || 'argument'} to be of type \\`${this.type}\\` but received type \\`${is_1.default(value)}\\``;\n            },\n            validator: value => is_1.default[typeString](value)\n        });\n    }\n    /**\n    @hidden\n    */\n    [base_predicate_1.testSymbol](value, main, label) {\n        // Create a map of labels -> received errors.\n        const errors = new Map();\n        for (const { validator, message } of this.context.validators) {\n            if (this.options.optional === true && value === undefined) {\n                continue;\n            }\n            let result;\n            try {\n                result = validator(value);\n            }\n            catch (error) {\n                // Any errors caught means validators couldn't process the input.\n                result = error;\n            }\n            if (result === true) {\n                continue;\n            }\n            const label2 = is_1.default.function_(label) ? label() : label;\n            const label_ = label2 ?\n                `${this.type} \\`${label2}\\`` :\n                this.type;\n            const mapKey = label2 || this.type;\n            // Get the current errors encountered for this label.\n            const currentErrors = errors.get(mapKey);\n            // Pre-generate the error message that will be reported to the user.\n            const errorMessage = message(value, label_, result);\n            // If we already have any errors for this label.\n            if (currentErrors) {\n                // If we don't already have this error logged, add it.\n                currentErrors.add(errorMessage);\n            }\n            else {\n                // Set this label and error in the full map.\n                errors.set(mapKey, new Set([errorMessage]));\n            }\n        }\n        // If we have any errors to report, throw.\n        if (errors.size > 0) {\n            // Generate the `error.message` property.\n            const message = generate_argument_error_message_1.generateArgumentErrorMessage(errors);\n            throw new argument_error_1.ArgumentError(message, main, errors);\n        }\n    }\n    /**\n    @hidden\n    */\n    get [exports.validatorSymbol]() {\n        return this.context.validators;\n    }\n    /**\n    Invert the following validators.\n    */\n    get not() {\n        return not_1.not(this);\n    }\n    /**\n    Test if the value matches a custom validation function. The validation function should return an object containing a `validator` and `message`. If the `validator` is `false`, the validation fails and the `message` will be used as error message. If the `message` is a function, the function is invoked with the `label` as argument to let you further customize the error message.\n\n    @param customValidator - Custom validation function.\n    */\n    validate(customValidator) {\n        return this.addValidator({\n            message: (_, label, error) => typeof error === 'string' ?\n                `(${label}) ${error}` :\n                error(label),\n            validator: value => {\n                const { message, validator } = customValidator(value);\n                if (validator) {\n                    return true;\n                }\n                return message;\n            }\n        });\n    }\n    /**\n    Test if the value matches a custom validation function. The validation function should return `true` if the value passes the function. If the function either returns `false` or a string, the function fails and the string will be used as error message.\n\n    @param validator - Validation function.\n    */\n    is(validator) {\n        return this.addValidator({\n            message: (value, label, error) => (error ?\n                `(${label}) ${error}` :\n                `Expected ${label} \\`${value}\\` to pass custom validation function`),\n            validator\n        });\n    }\n    /**\n    Provide a new error message to be thrown when the validation fails.\n\n    @param newMessage - Either a string containing the new message or a function returning the new message.\n\n    @example\n    ```\n    ow('ðŸŒˆ', 'unicorn', ow.string.equals('ðŸ¦„').message('Expected unicorn, got rainbow'));\n    //=> ArgumentError: Expected unicorn, got rainbow\n    ```\n\n    @example\n    ```\n    ow('ðŸŒˆ', ow.string.minLength(5).message((value, label) => `Expected ${label}, to have a minimum length of 5, got \\`${value}\\``));\n    //=> ArgumentError: Expected string, to be have a minimum length of 5, got `ðŸŒˆ`\n    ```\n    */\n    message(newMessage) {\n        const { validators } = this.context;\n        validators[validators.length - 1].message = (value, label) => {\n            if (typeof newMessage === 'function') {\n                return newMessage(value, label);\n            }\n            return newMessage;\n        };\n        return this;\n    }\n    /**\n    Register a new validator.\n\n    @param validator - Validator to register.\n    */\n    addValidator(validator) {\n        this.context.validators.push(validator);\n        return this;\n    }\n}\nexports.Predicate = Predicate;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}