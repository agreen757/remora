{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/project/remora/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _classCallCheck = require(\"/project/remora/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/project/remora/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/project/remora/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/project/remora/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SetPredicate = void 0;\nvar isEqual = require(\"lodash.isequal\");\nvar has_items_1 = require(\"../utils/has-items\");\nvar of_type_1 = require(\"../utils/of-type\");\nvar predicate_1 = require(\"./predicate\");\nvar SetPredicate = /*#__PURE__*/function (_predicate_1$Predicat) {\n  _inherits(SetPredicate, _predicate_1$Predicat);\n  var _super = _createSuper(SetPredicate);\n  /**\n  @hidden\n  */\n  function SetPredicate(options) {\n    _classCallCheck(this, SetPredicate);\n    return _super.call(this, 'Set', options);\n  }\n  /**\n  Test a Set to have a specific size.\n   @param size - The size of the Set.\n  */\n  _createClass(SetPredicate, [{\n    key: \"size\",\n    value: function size(_size) {\n      return this.addValidator({\n        message: function message(set, label) {\n          return \"Expected \".concat(label, \" to have size `\").concat(_size, \"`, got `\").concat(set.size, \"`\");\n        },\n        validator: function validator(set) {\n          return set.size === _size;\n        }\n      });\n    }\n    /**\n    Test a Set to have a minimum size.\n     @param size - The minimum size of the Set.\n    */\n  }, {\n    key: \"minSize\",\n    value: function minSize(size) {\n      return this.addValidator({\n        message: function message(set, label) {\n          return \"Expected \".concat(label, \" to have a minimum size of `\").concat(size, \"`, got `\").concat(set.size, \"`\");\n        },\n        validator: function validator(set) {\n          return set.size >= size;\n        },\n        negatedMessage: function negatedMessage(set, label) {\n          return \"Expected \".concat(label, \" to have a maximum size of `\").concat(size - 1, \"`, got `\").concat(set.size, \"`\");\n        }\n      });\n    }\n    /**\n    Test a Set to have a maximum size.\n     @param size - The maximum size of the Set.\n    */\n  }, {\n    key: \"maxSize\",\n    value: function maxSize(size) {\n      return this.addValidator({\n        message: function message(set, label) {\n          return \"Expected \".concat(label, \" to have a maximum size of `\").concat(size, \"`, got `\").concat(set.size, \"`\");\n        },\n        validator: function validator(set) {\n          return set.size <= size;\n        },\n        negatedMessage: function negatedMessage(set, label) {\n          return \"Expected \".concat(label, \" to have a minimum size of `\").concat(size + 1, \"`, got `\").concat(set.size, \"`\");\n        }\n      });\n    }\n    /**\n    Test a Set to include all the provided items. The items are tested by identity, not structure.\n     @param items - The items that should be a item in the Set.\n    */\n  }, {\n    key: \"has\",\n    value: function has() {\n      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n        items[_key] = arguments[_key];\n      }\n      return this.addValidator({\n        message: function message(_, label, missingItems) {\n          return \"Expected \".concat(label, \" to have items `\").concat(JSON.stringify(missingItems), \"`\");\n        },\n        validator: function validator(set) {\n          return has_items_1.default(set, items);\n        }\n      });\n    }\n    /**\n    Test a Set to include any of the provided items. The items are tested by identity, not structure.\n     @param items - The items that could be a item in the Set.\n    */\n  }, {\n    key: \"hasAny\",\n    value: function hasAny() {\n      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n      return this.addValidator({\n        message: function message(_, label) {\n          return \"Expected \".concat(label, \" to have any item of `\").concat(JSON.stringify(items), \"`\");\n        },\n        validator: function validator(set) {\n          return items.some(function (item) {\n            return set.has(item);\n          });\n        }\n      });\n    }\n    /**\n    Test all the items in the Set to match the provided predicate.\n     @param predicate - The predicate that should be applied against every item in the Set.\n    */\n  }, {\n    key: \"ofType\",\n    value: function ofType(predicate) {\n      return this.addValidator({\n        message: function message(_, label, error) {\n          return \"(\".concat(label, \") \").concat(error);\n        },\n        validator: function validator(set) {\n          return of_type_1.default(set, predicate);\n        }\n      });\n    }\n    /**\n    Test a Set to be empty.\n    */\n  }, {\n    key: \"empty\",\n    get: function get() {\n      return this.addValidator({\n        message: function message(set, label) {\n          return \"Expected \".concat(label, \" to be empty, got `\").concat(JSON.stringify(_toConsumableArray(set)), \"`\");\n        },\n        validator: function validator(set) {\n          return set.size === 0;\n        }\n      });\n    }\n    /**\n    Test a Set to be not empty.\n    */\n  }, {\n    key: \"nonEmpty\",\n    get: function get() {\n      return this.addValidator({\n        message: function message(_, label) {\n          return \"Expected \".concat(label, \" to not be empty\");\n        },\n        validator: function validator(set) {\n          return set.size > 0;\n        }\n      });\n    }\n    /**\n    Test a Set to be deeply equal to the provided Set.\n     @param expected - Expected Set to match.\n    */\n  }, {\n    key: \"deepEqual\",\n    value: function deepEqual(expected) {\n      return this.addValidator({\n        message: function message(set, label) {\n          return \"Expected \".concat(label, \" to be deeply equal to `\").concat(JSON.stringify(_toConsumableArray(expected)), \"`, got `\").concat(JSON.stringify(_toConsumableArray(set)), \"`\");\n        },\n        validator: function validator(set) {\n          return isEqual(set, expected);\n        }\n      });\n    }\n  }]);\n  return SetPredicate;\n}(predicate_1.Predicate);\nexports.SetPredicate = SetPredicate;","map":{"version":3,"names":["_toConsumableArray","require","default","_classCallCheck","_createClass","_inherits","_createSuper","Object","defineProperty","exports","value","SetPredicate","isEqual","has_items_1","of_type_1","predicate_1","_predicate_1$Predicat","_super","options","call","key","size","addValidator","message","set","label","concat","validator","minSize","negatedMessage","maxSize","has","_len","arguments","length","items","Array","_key","_","missingItems","JSON","stringify","hasAny","_len2","_key2","some","item","ofType","predicate","error","get","deepEqual","expected","Predicate"],"sources":["/project/remora/node_modules/ow/dist/predicates/set.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetPredicate = void 0;\nconst isEqual = require(\"lodash.isequal\");\nconst has_items_1 = require(\"../utils/has-items\");\nconst of_type_1 = require(\"../utils/of-type\");\nconst predicate_1 = require(\"./predicate\");\nclass SetPredicate extends predicate_1.Predicate {\n    /**\n    @hidden\n    */\n    constructor(options) {\n        super('Set', options);\n    }\n    /**\n    Test a Set to have a specific size.\n\n    @param size - The size of the Set.\n    */\n    size(size) {\n        return this.addValidator({\n            message: (set, label) => `Expected ${label} to have size \\`${size}\\`, got \\`${set.size}\\``,\n            validator: set => set.size === size\n        });\n    }\n    /**\n    Test a Set to have a minimum size.\n\n    @param size - The minimum size of the Set.\n    */\n    minSize(size) {\n        return this.addValidator({\n            message: (set, label) => `Expected ${label} to have a minimum size of \\`${size}\\`, got \\`${set.size}\\``,\n            validator: set => set.size >= size,\n            negatedMessage: (set, label) => `Expected ${label} to have a maximum size of \\`${size - 1}\\`, got \\`${set.size}\\``\n        });\n    }\n    /**\n    Test a Set to have a maximum size.\n\n    @param size - The maximum size of the Set.\n    */\n    maxSize(size) {\n        return this.addValidator({\n            message: (set, label) => `Expected ${label} to have a maximum size of \\`${size}\\`, got \\`${set.size}\\``,\n            validator: set => set.size <= size,\n            negatedMessage: (set, label) => `Expected ${label} to have a minimum size of \\`${size + 1}\\`, got \\`${set.size}\\``\n        });\n    }\n    /**\n    Test a Set to include all the provided items. The items are tested by identity, not structure.\n\n    @param items - The items that should be a item in the Set.\n    */\n    has(...items) {\n        return this.addValidator({\n            message: (_, label, missingItems) => `Expected ${label} to have items \\`${JSON.stringify(missingItems)}\\``,\n            validator: set => has_items_1.default(set, items)\n        });\n    }\n    /**\n    Test a Set to include any of the provided items. The items are tested by identity, not structure.\n\n    @param items - The items that could be a item in the Set.\n    */\n    hasAny(...items) {\n        return this.addValidator({\n            message: (_, label) => `Expected ${label} to have any item of \\`${JSON.stringify(items)}\\``,\n            validator: set => items.some(item => set.has(item))\n        });\n    }\n    /**\n    Test all the items in the Set to match the provided predicate.\n\n    @param predicate - The predicate that should be applied against every item in the Set.\n    */\n    ofType(predicate) {\n        return this.addValidator({\n            message: (_, label, error) => `(${label}) ${error}`,\n            validator: set => of_type_1.default(set, predicate)\n        });\n    }\n    /**\n    Test a Set to be empty.\n    */\n    get empty() {\n        return this.addValidator({\n            message: (set, label) => `Expected ${label} to be empty, got \\`${JSON.stringify([...set])}\\``,\n            validator: set => set.size === 0\n        });\n    }\n    /**\n    Test a Set to be not empty.\n    */\n    get nonEmpty() {\n        return this.addValidator({\n            message: (_, label) => `Expected ${label} to not be empty`,\n            validator: set => set.size > 0\n        });\n    }\n    /**\n    Test a Set to be deeply equal to the provided Set.\n\n    @param expected - Expected Set to match.\n    */\n    deepEqual(expected) {\n        return this.addValidator({\n            message: (set, label) => `Expected ${label} to be deeply equal to \\`${JSON.stringify([...expected])}\\`, got \\`${JSON.stringify([...set])}\\``,\n            validator: set => isEqual(set, expected)\n        });\n    }\n}\nexports.SetPredicate = SetPredicate;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}