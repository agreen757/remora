{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/project/remora/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _slicedToArray = require(\"/project/remora/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _toConsumableArray = require(\"/project/remora/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateArgumentErrorMessage = void 0;\n/**\nGenerates a complete message from all errors generated by predicates.\n\n@param errors - The errors generated by the predicates.\n@param isAny - If this function is called from the any argument.\n@hidden\n*/\nvar generateArgumentErrorMessage = function generateArgumentErrorMessage(errors) {\n  var isAny = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var message = [];\n  var errorArray = _toConsumableArray(errors.entries());\n  var anyErrorWithoutOneItemOnly = errorArray.some(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      array = _ref2[1];\n    return array.size !== 1;\n  });\n  // If only one error \"key\" is present, enumerate all of those errors only.\n  if (errorArray.length === 1) {\n    var _errorArray$ = _slicedToArray(errorArray[0], 2),\n      returnedErrors = _errorArray$[1];\n    if (!isAny && returnedErrors.size === 1) {\n      var _returnedErrors = _slicedToArray(returnedErrors, 1),\n        errorMessage = _returnedErrors[0];\n      return errorMessage;\n    }\n    var _iterator = _createForOfIteratorHelper(returnedErrors),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var entry = _step.value;\n        message.push(\"\".concat(isAny ? '  - ' : '').concat(entry));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return message.join('\\n');\n  }\n  // If every predicate returns just one error, enumerate them as is.\n  if (!anyErrorWithoutOneItemOnly) {\n    return errorArray.map(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n        _ref4$ = _slicedToArray(_ref4[1], 1),\n        item = _ref4$[0];\n      return \"  - \".concat(item);\n    }).join('\\n');\n  }\n  // Else, iterate through all the errors and enumerate them.\n  var _iterator2 = _createForOfIteratorHelper(errorArray),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n        key = _step2$value[0],\n        value = _step2$value[1];\n      message.push(\"Errors from the \\\"\".concat(key, \"\\\" predicate:\"));\n      var _iterator3 = _createForOfIteratorHelper(value),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _entry = _step3.value;\n          message.push(\"  - \".concat(_entry));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return message.join('\\n');\n};\nexports.generateArgumentErrorMessage = generateArgumentErrorMessage;","map":{"version":3,"names":["_createForOfIteratorHelper","require","default","_slicedToArray","_toConsumableArray","Object","defineProperty","exports","value","generateArgumentErrorMessage","errors","isAny","arguments","length","undefined","message","errorArray","entries","anyErrorWithoutOneItemOnly","some","_ref","_ref2","array","size","_errorArray$","returnedErrors","_returnedErrors","errorMessage","_iterator","_step","s","n","done","entry","push","concat","err","e","f","join","map","_ref3","_ref4","_ref4$","item","_iterator2","_step2","_step2$value","key","_iterator3","_step3"],"sources":["/project/remora/node_modules/ow/dist/utils/generate-argument-error-message.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateArgumentErrorMessage = void 0;\n/**\nGenerates a complete message from all errors generated by predicates.\n\n@param errors - The errors generated by the predicates.\n@param isAny - If this function is called from the any argument.\n@hidden\n*/\nconst generateArgumentErrorMessage = (errors, isAny = false) => {\n    const message = [];\n    const errorArray = [...errors.entries()];\n    const anyErrorWithoutOneItemOnly = errorArray.some(([, array]) => array.size !== 1);\n    // If only one error \"key\" is present, enumerate all of those errors only.\n    if (errorArray.length === 1) {\n        const [, returnedErrors] = errorArray[0];\n        if (!isAny && returnedErrors.size === 1) {\n            const [errorMessage] = returnedErrors;\n            return errorMessage;\n        }\n        for (const entry of returnedErrors) {\n            message.push(`${isAny ? '  - ' : ''}${entry}`);\n        }\n        return message.join('\\n');\n    }\n    // If every predicate returns just one error, enumerate them as is.\n    if (!anyErrorWithoutOneItemOnly) {\n        return errorArray.map(([, [item]]) => `  - ${item}`).join('\\n');\n    }\n    // Else, iterate through all the errors and enumerate them.\n    for (const [key, value] of errorArray) {\n        message.push(`Errors from the \"${key}\" predicate:`);\n        for (const entry of value) {\n            message.push(`  - ${entry}`);\n        }\n    }\n    return message.join('\\n');\n};\nexports.generateArgumentErrorMessage = generateArgumentErrorMessage;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}