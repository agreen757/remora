{"ast":null,"code":"var contentTypeParser = require('content-type');\nvar _require = require('./utils'),\n  isNode = _require.isNode;\nvar CONTENT_TYPE_JSON = 'application/json';\nvar STRINGIFIABLE_CONTENT_TYPE_RXS = [new RegExp(\"^\".concat(CONTENT_TYPE_JSON), 'i'), /^application\\/.*xml$/i, /^text\\//i];\n\n/**\n * Parses a Buffer or ArrayBuffer using the provided content type header.\n *\n * - application/json is returned as a parsed object.\n * - application/*xml and text/* are returned as strings.\n * - everything else is returned as original body.\n *\n * If the header includes a charset, the body will be stringified only\n * if the charset represents a known encoding to Node.js or Browser.\n *\n * @param {Buffer|ArrayBuffer} body\n * @param {string} contentTypeHeader\n * @return {string|Object|Buffer|ArrayBuffer}\n */\nexports.maybeParseBody = function (body, contentTypeHeader) {\n  var contentType;\n  var charset;\n  try {\n    var result = contentTypeParser.parse(contentTypeHeader);\n    contentType = result.type;\n    charset = result.parameters.charset;\n  } catch (err) {\n    // can't parse, keep original body\n    return body;\n  }\n\n  // If we can't successfully parse it, we return\n  // the original buffer rather than a mangled string.\n  if (!areDataStringifiable(contentType, charset)) return body;\n  var dataString = isomorphicBufferToString(body, charset);\n  return contentType === CONTENT_TYPE_JSON ? JSON.parse(dataString) : dataString;\n};\n\n/**\n * @param {Buffer|ArrayBuffer} buffer\n * @param {string} encoding\n * @return {string}\n */\nfunction isomorphicBufferToString(buffer, encoding) {\n  if (buffer.constructor.name !== ArrayBuffer.name) {\n    return buffer.toString(encoding);\n  }\n\n  // Browser decoding only works with UTF-8.\n  var utf8decoder = new TextDecoder();\n  return utf8decoder.decode(new Uint8Array(buffer));\n}\n\n/**\n * @param {string} charset\n * @return {boolean}\n */\nfunction isCharsetStringifiable(charset) {\n  if (!charset) return true; // hope that it's utf-8\n  if (isNode()) return Buffer.isEncoding(charset);\n  var normalizedCharset = charset.toLowerCase().replace('-', '');\n  // Browsers only support decoding utf-8 buffers.\n  return normalizedCharset === 'utf8';\n}\n\n/**\n * @param {string} contentType\n * @return {boolean}\n */\nfunction isContentTypeStringifiable(contentType) {\n  if (!contentType) return false; // keep buffer\n  return STRINGIFIABLE_CONTENT_TYPE_RXS.some(function (rx) {\n    return rx.test(contentType);\n  });\n}\n\n/**\n * @param {string} contentType\n * @param {string} charset\n * @return {boolean}\n */\nfunction areDataStringifiable(contentType, charset) {\n  return isContentTypeStringifiable(contentType) && isCharsetStringifiable(charset);\n}","map":{"version":3,"names":["contentTypeParser","require","_require","isNode","CONTENT_TYPE_JSON","STRINGIFIABLE_CONTENT_TYPE_RXS","RegExp","concat","exports","maybeParseBody","body","contentTypeHeader","contentType","charset","result","parse","type","parameters","err","areDataStringifiable","dataString","isomorphicBufferToString","JSON","buffer","encoding","constructor","name","ArrayBuffer","toString","utf8decoder","TextDecoder","decode","Uint8Array","isCharsetStringifiable","Buffer","isEncoding","normalizedCharset","toLowerCase","replace","isContentTypeStringifiable","some","rx","test"],"sources":["/project/remora/node_modules/apify-client/src/body_parser.js"],"sourcesContent":["const contentTypeParser = require('content-type');\nconst { isNode } = require('./utils');\n\nconst CONTENT_TYPE_JSON = 'application/json';\nconst STRINGIFIABLE_CONTENT_TYPE_RXS = [\n    new RegExp(`^${CONTENT_TYPE_JSON}`, 'i'),\n    /^application\\/.*xml$/i,\n    /^text\\//i,\n];\n\n/**\n * Parses a Buffer or ArrayBuffer using the provided content type header.\n *\n * - application/json is returned as a parsed object.\n * - application/*xml and text/* are returned as strings.\n * - everything else is returned as original body.\n *\n * If the header includes a charset, the body will be stringified only\n * if the charset represents a known encoding to Node.js or Browser.\n *\n * @param {Buffer|ArrayBuffer} body\n * @param {string} contentTypeHeader\n * @return {string|Object|Buffer|ArrayBuffer}\n */\nexports.maybeParseBody = (body, contentTypeHeader) => {\n    let contentType;\n    let charset;\n    try {\n        const result = contentTypeParser.parse(contentTypeHeader);\n        contentType = result.type;\n        charset = result.parameters.charset;\n    } catch (err) {\n        // can't parse, keep original body\n        return body;\n    }\n\n    // If we can't successfully parse it, we return\n    // the original buffer rather than a mangled string.\n    if (!areDataStringifiable(contentType, charset)) return body;\n    const dataString = isomorphicBufferToString(body, charset);\n\n    return contentType === CONTENT_TYPE_JSON\n        ? JSON.parse(dataString)\n        : dataString;\n};\n\n/**\n * @param {Buffer|ArrayBuffer} buffer\n * @param {string} encoding\n * @return {string}\n */\nfunction isomorphicBufferToString(buffer, encoding) {\n    if (buffer.constructor.name !== ArrayBuffer.name) {\n        return buffer.toString(encoding);\n    }\n\n    // Browser decoding only works with UTF-8.\n    const utf8decoder = new TextDecoder();\n    return utf8decoder.decode(new Uint8Array(buffer));\n}\n\n/**\n * @param {string} charset\n * @return {boolean}\n */\nfunction isCharsetStringifiable(charset) {\n    if (!charset) return true; // hope that it's utf-8\n    if (isNode()) return Buffer.isEncoding(charset);\n    const normalizedCharset = charset.toLowerCase().replace('-', '');\n    // Browsers only support decoding utf-8 buffers.\n    return normalizedCharset === 'utf8';\n}\n\n/**\n * @param {string} contentType\n * @return {boolean}\n */\nfunction isContentTypeStringifiable(contentType) {\n    if (!contentType) return false; // keep buffer\n    return STRINGIFIABLE_CONTENT_TYPE_RXS.some((rx) => rx.test(contentType));\n}\n\n/**\n * @param {string} contentType\n * @param {string} charset\n * @return {boolean}\n */\nfunction areDataStringifiable(contentType, charset) {\n    return isContentTypeStringifiable(contentType) && isCharsetStringifiable(charset);\n}\n"],"mappings":"AAAA,IAAMA,iBAAiB,GAAGC,OAAO,CAAC,cAAc,CAAC;AACjD,IAAAC,QAAA,GAAmBD,OAAO,CAAC,SAAS,CAAC;EAA7BE,MAAM,GAAAD,QAAA,CAANC,MAAM;AAEd,IAAMC,iBAAiB,GAAG,kBAAkB;AAC5C,IAAMC,8BAA8B,GAAG,CACnC,IAAIC,MAAM,KAAAC,MAAA,CAAKH,iBAAiB,GAAI,GAAG,CAAC,EACxC,uBAAuB,EACvB,UAAU,CACb;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAI,OAAO,CAACC,cAAc,GAAG,UAACC,IAAI,EAAEC,iBAAiB,EAAK;EAClD,IAAIC,WAAW;EACf,IAAIC,OAAO;EACX,IAAI;IACA,IAAMC,MAAM,GAAGd,iBAAiB,CAACe,KAAK,CAACJ,iBAAiB,CAAC;IACzDC,WAAW,GAAGE,MAAM,CAACE,IAAI;IACzBH,OAAO,GAAGC,MAAM,CAACG,UAAU,CAACJ,OAAO;EACvC,CAAC,CAAC,OAAOK,GAAG,EAAE;IACV;IACA,OAAOR,IAAI;EACf;;EAEA;EACA;EACA,IAAI,CAACS,oBAAoB,CAACP,WAAW,EAAEC,OAAO,CAAC,EAAE,OAAOH,IAAI;EAC5D,IAAMU,UAAU,GAAGC,wBAAwB,CAACX,IAAI,EAAEG,OAAO,CAAC;EAE1D,OAAOD,WAAW,KAAKR,iBAAiB,GAClCkB,IAAI,CAACP,KAAK,CAACK,UAAU,CAAC,GACtBA,UAAU;AACpB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,SAASC,wBAAwBA,CAACE,MAAM,EAAEC,QAAQ,EAAE;EAChD,IAAID,MAAM,CAACE,WAAW,CAACC,IAAI,KAAKC,WAAW,CAACD,IAAI,EAAE;IAC9C,OAAOH,MAAM,CAACK,QAAQ,CAACJ,QAAQ,CAAC;EACpC;;EAEA;EACA,IAAMK,WAAW,GAAG,IAAIC,WAAW,CAAC,CAAC;EACrC,OAAOD,WAAW,CAACE,MAAM,CAAC,IAAIC,UAAU,CAACT,MAAM,CAAC,CAAC;AACrD;;AAEA;AACA;AACA;AACA;AACA,SAASU,sBAAsBA,CAACpB,OAAO,EAAE;EACrC,IAAI,CAACA,OAAO,EAAE,OAAO,IAAI,CAAC,CAAC;EAC3B,IAAIV,MAAM,CAAC,CAAC,EAAE,OAAO+B,MAAM,CAACC,UAAU,CAACtB,OAAO,CAAC;EAC/C,IAAMuB,iBAAiB,GAAGvB,OAAO,CAACwB,WAAW,CAAC,CAAC,CAACC,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC;EAChE;EACA,OAAOF,iBAAiB,KAAK,MAAM;AACvC;;AAEA;AACA;AACA;AACA;AACA,SAASG,0BAA0BA,CAAC3B,WAAW,EAAE;EAC7C,IAAI,CAACA,WAAW,EAAE,OAAO,KAAK,CAAC,CAAC;EAChC,OAAOP,8BAA8B,CAACmC,IAAI,CAAC,UAACC,EAAE;IAAA,OAAKA,EAAE,CAACC,IAAI,CAAC9B,WAAW,CAAC;EAAA,EAAC;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASO,oBAAoBA,CAACP,WAAW,EAAEC,OAAO,EAAE;EAChD,OAAO0B,0BAA0B,CAAC3B,WAAW,CAAC,IAAIqB,sBAAsB,CAACpB,OAAO,CAAC;AACrF"},"metadata":{},"sourceType":"script","externalDependencies":[]}