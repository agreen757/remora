{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateInputSchema = exports.parseAjvError = void 0;\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\nvar _input_schema = _interopRequireDefault(require(\"./input_schema.json\"));\nvar _intl = require(\"./intl\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar definitions = _input_schema.default.definitions;\n/**\n * This function parses AJV error and transformes it into a redable string.\n *\n * @param error An error as returned from AJV.\n * @param rootName Usually 'input' or 'schema' based on if we are passing the input or schema.\n * @param properties (Used only when parsing input errors) List of input schema properties.\n * @param input (Used only when parsing input errors) Actual input that is being parsed.\n * @returns {null|{fieldKey: *, message: *}}\n */\n\nvar parseAjvError = function parseAjvError(error, rootName) {\n  var properties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var input = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  // There are 3 possible errors comming from validation:\n  // - either { keword: 'anything', dataPath: '.someField', message: 'error message that we can use' }\n  // - or { keyword: 'additionalProperties', params: { additionalProperty: 'field' }, message: 'should NOT have additional properties' }\n  // - or { keyword: 'required', dataPath: '', params.missingProperty: 'someField' }\n  var fieldKey;\n  var message; // If error is with keyword type, it means that type of input is incorrect\n  // this can mean that provided value is null\n\n  if (error.keyword === 'type') {\n    fieldKey = error.dataPath.split('.').pop(); // Check if value is null and field is nullable, if yes, then skip this error\n\n    if (properties[fieldKey] && properties[fieldKey].nullable && input[fieldKey] === null) {\n      return null;\n    }\n    message = (0, _intl.m)('inputSchema.validation.generic', {\n      rootName: rootName,\n      fieldKey: fieldKey,\n      message: error.message\n    });\n  } else if (error.keyword === 'required') {\n    fieldKey = error.params.missingProperty;\n    message = (0, _intl.m)('inputSchema.validation.required', {\n      rootName: rootName,\n      fieldKey: fieldKey\n    });\n  } else if (error.keyword === 'additionalProperties') {\n    fieldKey = error.params.additionalProperty;\n    message = (0, _intl.m)('inputSchema.validation.additionalProperty', {\n      rootName: rootName,\n      fieldKey: fieldKey\n    });\n  } else {\n    fieldKey = error.dataPath.split('.').pop();\n    message = (0, _intl.m)('inputSchema.validation.generic', {\n      rootName: rootName,\n      fieldKey: fieldKey,\n      message: error.message\n    });\n  }\n  return {\n    fieldKey: fieldKey,\n    message: message\n  };\n};\n/**\n * Validates given object against schema and throws a human readable error.\n */\n\nexports.parseAjvError = parseAjvError;\nvar validateAgainstSchemaOrThrow = function validateAgainstSchemaOrThrow(validator, obj, inputSchema, rootName) {\n  if (validator.validate(inputSchema, obj)) return;\n  var errorMessage = parseAjvError(validator.errors[0], rootName).message;\n  throw new Error(\"Input schema is not valid (\".concat(errorMessage, \")\"));\n};\n/**\n * This validates given object only against the basic input schema without checking the particular fields.\n * We override schema.properties.properties not to validate field defitions.\n */\n\nvar validateBasicStructure = function validateBasicStructure(validator, obj) {\n  var schemaWithoutProperties = _objectSpread({}, _input_schema.default);\n  schemaWithoutProperties.properties = _objectSpread(_objectSpread({}, _input_schema.default.properties), {}, {\n    properties: {\n      type: 'object'\n    }\n  });\n  validateAgainstSchemaOrThrow(validator, obj, schemaWithoutProperties, 'schema');\n};\n/**\n * Validates particular field against it's schema.\n */\n\nvar validateField = function validateField(validator, fieldSchema, fieldKey) {\n  var matchingDefinitions = Object.values(definitions).filter(function (definition) {\n    return definition.properties.type.enum // This is a normal case where fieldSchema.type can be only one possible value matching definition.properties.type.enum.0\n    ? definition.properties.type.enum[0] === fieldSchema.type // This is a type \"Any\" where fieldSchema.type is an array of possible values\n    : _underscore.default.isArray(fieldSchema.type);\n  }); // There is not matching definition.\n\n  if (matchingDefinitions.length === 0) {\n    var errorMessage = (0, _intl.m)('inputSchema.validation.noMatchingDefinition', {\n      fieldKey: fieldKey\n    });\n    throw new Error(\"Input schema is not valid (\".concat(errorMessage, \")\"));\n  } // If there is only one matching then we are done and simply compare it.\n\n  if (matchingDefinitions.length === 1) {\n    validateAgainstSchemaOrThrow(validator, fieldSchema, matchingDefinitions[0], \"schema.properties.\".concat(fieldKey));\n    return;\n  } // If there are more matching definitions then the type is string and we need to get the right one.\n  // If the definition contains \"enum\" property then it's enum type.\n\n  if (fieldSchema.enum) {\n    var _definition = matchingDefinitions.filter(function (item) {\n      return !!item.properties.enum;\n    }).pop();\n    if (!_definition) throw new Error('Input schema validation failed to find \"enum property\" definition');\n    validateAgainstSchemaOrThrow(validator, fieldSchema, _definition, \"schema.properties.\".concat(fieldKey));\n    return;\n  } // Otherwise we use the other definition.\n\n  var definition = matchingDefinitions.filter(function (item) {\n    return !item.properties.enum;\n  }).pop();\n  if (!definition) throw new Error('Input schema validation failed to find other than \"enum property\" definition');\n  validateAgainstSchemaOrThrow(validator, fieldSchema, definition, \"schema.properties.\".concat(fieldKey));\n};\n/**\n * This function validates given input schema first just for basic structure then each field one by one and\n * finally fully against the whole schema.\n *\n * This way we get the most accurate error message for user.\n */\n\nvar validateInputSchema = function validateInputSchema(validator, inputSchema) {\n  // First validate just basic structure without fields.\n  validateBasicStructure(validator, inputSchema); // Then validate each field speparately.\n\n  _underscore.default.mapObject(inputSchema.properties, function (fieldSchema, fieldKey) {\n    return validateField(validator, fieldSchema, fieldKey);\n  }); // Finally just to be sure run validation against the whole shema.\n\n  validateAgainstSchemaOrThrow(validator, inputSchema, _input_schema.default, 'schema');\n};\nexports.validateInputSchema = validateInputSchema;","map":{"version":3,"names":["Object","defineProperty","exports","value","validateInputSchema","parseAjvError","_underscore","_interopRequireDefault","require","_input_schema","_intl","obj","__esModule","default","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","definitions","error","rootName","properties","undefined","input","fieldKey","message","keyword","dataPath","split","pop","nullable","m","params","missingProperty","additionalProperty","validateAgainstSchemaOrThrow","validator","inputSchema","validate","errorMessage","errors","Error","concat","validateBasicStructure","schemaWithoutProperties","type","validateField","fieldSchema","matchingDefinitions","values","definition","enum","isArray","item","mapObject"],"sources":["/project/remora/node_modules/apify-shared/input_schema.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateInputSchema = exports.parseAjvError = void 0;\n\nvar _underscore = _interopRequireDefault(require(\"underscore\"));\n\nvar _input_schema = _interopRequireDefault(require(\"./input_schema.json\"));\n\nvar _intl = require(\"./intl\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst {\n  definitions\n} = _input_schema.default;\n/**\n * This function parses AJV error and transformes it into a redable string.\n *\n * @param error An error as returned from AJV.\n * @param rootName Usually 'input' or 'schema' based on if we are passing the input or schema.\n * @param properties (Used only when parsing input errors) List of input schema properties.\n * @param input (Used only when parsing input errors) Actual input that is being parsed.\n * @returns {null|{fieldKey: *, message: *}}\n */\n\nconst parseAjvError = (error, rootName, properties = {}, input = {}) => {\n  // There are 3 possible errors comming from validation:\n  // - either { keword: 'anything', dataPath: '.someField', message: 'error message that we can use' }\n  // - or { keyword: 'additionalProperties', params: { additionalProperty: 'field' }, message: 'should NOT have additional properties' }\n  // - or { keyword: 'required', dataPath: '', params.missingProperty: 'someField' }\n  let fieldKey;\n  let message; // If error is with keyword type, it means that type of input is incorrect\n  // this can mean that provided value is null\n\n  if (error.keyword === 'type') {\n    fieldKey = error.dataPath.split('.').pop(); // Check if value is null and field is nullable, if yes, then skip this error\n\n    if (properties[fieldKey] && properties[fieldKey].nullable && input[fieldKey] === null) {\n      return null;\n    }\n\n    message = (0, _intl.m)('inputSchema.validation.generic', {\n      rootName,\n      fieldKey,\n      message: error.message\n    });\n  } else if (error.keyword === 'required') {\n    fieldKey = error.params.missingProperty;\n    message = (0, _intl.m)('inputSchema.validation.required', {\n      rootName,\n      fieldKey\n    });\n  } else if (error.keyword === 'additionalProperties') {\n    fieldKey = error.params.additionalProperty;\n    message = (0, _intl.m)('inputSchema.validation.additionalProperty', {\n      rootName,\n      fieldKey\n    });\n  } else {\n    fieldKey = error.dataPath.split('.').pop();\n    message = (0, _intl.m)('inputSchema.validation.generic', {\n      rootName,\n      fieldKey,\n      message: error.message\n    });\n  }\n\n  return {\n    fieldKey,\n    message\n  };\n};\n/**\n * Validates given object against schema and throws a human readable error.\n */\n\n\nexports.parseAjvError = parseAjvError;\n\nconst validateAgainstSchemaOrThrow = (validator, obj, inputSchema, rootName) => {\n  if (validator.validate(inputSchema, obj)) return;\n  const errorMessage = parseAjvError(validator.errors[0], rootName).message;\n  throw new Error(`Input schema is not valid (${errorMessage})`);\n};\n/**\n * This validates given object only against the basic input schema without checking the particular fields.\n * We override schema.properties.properties not to validate field defitions.\n */\n\n\nconst validateBasicStructure = (validator, obj) => {\n  const schemaWithoutProperties = _objectSpread({}, _input_schema.default);\n\n  schemaWithoutProperties.properties = _objectSpread(_objectSpread({}, _input_schema.default.properties), {}, {\n    properties: {\n      type: 'object'\n    }\n  });\n  validateAgainstSchemaOrThrow(validator, obj, schemaWithoutProperties, 'schema');\n};\n/**\n * Validates particular field against it's schema.\n */\n\n\nconst validateField = (validator, fieldSchema, fieldKey) => {\n  const matchingDefinitions = Object.values(definitions).filter(definition => {\n    return definition.properties.type.enum // This is a normal case where fieldSchema.type can be only one possible value matching definition.properties.type.enum.0\n    ? definition.properties.type.enum[0] === fieldSchema.type // This is a type \"Any\" where fieldSchema.type is an array of possible values\n    : _underscore.default.isArray(fieldSchema.type);\n  }); // There is not matching definition.\n\n  if (matchingDefinitions.length === 0) {\n    const errorMessage = (0, _intl.m)('inputSchema.validation.noMatchingDefinition', {\n      fieldKey\n    });\n    throw new Error(`Input schema is not valid (${errorMessage})`);\n  } // If there is only one matching then we are done and simply compare it.\n\n\n  if (matchingDefinitions.length === 1) {\n    validateAgainstSchemaOrThrow(validator, fieldSchema, matchingDefinitions[0], `schema.properties.${fieldKey}`);\n    return;\n  } // If there are more matching definitions then the type is string and we need to get the right one.\n  // If the definition contains \"enum\" property then it's enum type.\n\n\n  if (fieldSchema.enum) {\n    const definition = matchingDefinitions.filter(item => !!item.properties.enum).pop();\n    if (!definition) throw new Error('Input schema validation failed to find \"enum property\" definition');\n    validateAgainstSchemaOrThrow(validator, fieldSchema, definition, `schema.properties.${fieldKey}`);\n    return;\n  } // Otherwise we use the other definition.\n\n\n  const definition = matchingDefinitions.filter(item => !item.properties.enum).pop();\n  if (!definition) throw new Error('Input schema validation failed to find other than \"enum property\" definition');\n  validateAgainstSchemaOrThrow(validator, fieldSchema, definition, `schema.properties.${fieldKey}`);\n};\n/**\n * This function validates given input schema first just for basic structure then each field one by one and\n * finally fully against the whole schema.\n *\n * This way we get the most accurate error message for user.\n */\n\n\nconst validateInputSchema = (validator, inputSchema) => {\n  // First validate just basic structure without fields.\n  validateBasicStructure(validator, inputSchema); // Then validate each field speparately.\n\n  _underscore.default.mapObject(inputSchema.properties, (fieldSchema, fieldKey) => validateField(validator, fieldSchema, fieldKey)); // Finally just to be sure run validation against the whole shema.\n\n\n  validateAgainstSchemaOrThrow(validator, inputSchema, _input_schema.default, 'schema');\n};\n\nexports.validateInputSchema = validateInputSchema;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}